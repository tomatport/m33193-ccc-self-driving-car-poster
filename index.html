<!DOCTYPE html>
<html lang="en-GB">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=3840, height=2160, initial-scale=1.0">
	
	<title>Designing an Ethical Engine for a Self-Driving Car</title>
	
	<link rel="stylesheet" href="style.css">

	<!-- Google Fonts -->
	<link rel="preconnect" href="https://fonts.googleapis.com">
	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link href="https://fonts.googleapis.com/css2?family=Atkinson+Hyperlegible:ital,wght@0,400;0,700;1,400;1,700&display=swap" rel="stylesheet">
</head>
<body>
	<aside id="background">
		<!-- separate element to apply filters and etc -->
	</aside>

	<main>
		<article>
			<section class="col">
				<header class="step">
					<h1 id="title">Designing an 'Ethical Engine' for a Self-Driving Car</h1>
					<p class="subtitle" id="module">
						<span class="module-id">M33193</span> <span class="module-name">Core Computing Concepts</span>&mdash;<span class="coursework">CW Item 1</span>
					</p>
					<p class="subtitle" id="author">
						<span class="name">Thomas Robinson</span>
						<span class="up-number">up2194485</span>
					</p>

					<p>
						This poster will demonstrate the process of designing an 'ethical engine' for a self driving car,
						utilising the concepts of graph theory, route finding algorithms, and applying ethical decision making to risk analysis.
					</p>
				</header>

				<section class="step">
					<h2>Creating the Graph</h2>
					<!--
						image of the town, then image of simple graph
						this should include the distance weightings
					-->
					<div style="display: flex;">
						<ol style="flex: 2">
							<li>
								The map of the town must be converted into a graph
							</li>
							<li>
								Each intersection is translated into a node, and each road is translated into an edge
							</li>
							<li>
								The distance of each road is used as the weight of each edge
							</li>
							<li>
								The layout of the graph does not need to reflect the layout of the town, though we will use the same layout for simplicity
							</li>
						</ol>	

						<figure id="fading-thing">
							<img src="img/Town1.png">

							<img src="img/Town1Distances.png">
						</figure>
					</div>
				</section>

				<section class="step">
					<h2>The Fastest Route</h2>
					<ol>
						<li>
							A* is popular, efficient, and easy to understand.
						</li>
						<li>
							It may not always find the fastest route like Dijkstra's algorithm, but is more efficient.
						</li>
						<li>
							The heuristic function is the straight-line distance to the destination node.
						</li>
						<li>
							A constant speed is assumed, with no backtracking. The algorithm is ran once.
						</li>
					</ol>

					<figure class="frames">
						<ul>
							<li class="frame" data-frame="1">
								<div>
									<img src="img/Town1ShortestFrames/Graph1.svg">

									<p>We calculate the values for each node connected to the <b>Start</b> node (<b>B</b>, <b>C</b>, <b>G</b>, <b>H</b>, <b>I</b>), by adding the distance value and the heuristic. Each of the connected nodes are marked as coming from the <b>Start</b> node.</p>
								</div>
								
								
								<div>
									<img src="img/Town1ShortestFrames/Table1.png">
								</div>
							</li>

								<li class="frame" data-frame="2">
									<div>
										<img src="img/Town1ShortestFrames/Graph2.svg">
										<p>Node <b>H</b> had the lowest <code>f</code> value (distance + heuristic), so we move on to <b>H</b> and mark <b>Start</b> as visited. The process repeats; we check the nodes connected to <b>H</b>, but ignore <b>Start</b> as it has already been visited.</p>			
									</div>

									<div>
										<img src="img/Town1ShortestFrames/Table2.png">
									</div>
								</li>

								<li class="frame" data-frame="3">
									<div>
										<img src="img/Town1ShortestFrames/Graph3.svg">
										<p>As before, we move onto <b>O</b> since it has the lowest <code>f</code> value, calculate the <code>f</code> values of its neighbours, and mark it as visited.</p>			
									</div>
									
									<div>
										<img src="img/Town1ShortestFrames/Table3.png">
									</div>
								</li>

								<li class="frame" data-frame="4">
									<div>
										<img src="img/Town1ShortestFrames/Graph4.svg">
										<p>We continue the process, moving onto <b>X</b></p>		
									</div>
									
									<div>
										<img src="img/Town1ShortestFrames/Table4.png">
									</div>
								</li>

								<li class="frame" data-frame="5">
									<div>
										<img src="img/Town1ShortestFrames/Graph5.svg">
										<p>Now we are at the end node, we work backwards from the <b>End</b> node, using the <code>Previous</code> column. This is our shortest route.</p>
									</div>
									
									<div>
										<img src="img/Town1ShortestFrames/Table5.png">
									</div>
								</li>
							</ul>
					</figure>
				</section>
			</section>

			<section class="col">
				<section class="step">
					<h2>Factoring in Risk</h2>
					<ol>
						<li>
							To factor in the risk of the route, the busyness of the areas on the map were used. It can be assumed that the busier an area is, the more likely it is that an accident will take place.
						</li>
						<li>
							A risk value can be assigned to each area, and take the risk of the most dangerous area that the road borders. This is a utilitarianist approach, as it maximises the safety of the passengers and pedestrians using an objective method. 
						</li>
						<li>
							An algorithm is unable to subscribe to deontological principles, as it is unable to make moral judgements. Defining deontological rules for the car to follow is infeasible, as it would be impossible to account for every possible scenario, and the ethics of every situation are inherently subjective. Virtue ethics would also require the car to have a 'moral compass,' which is not possible.
						</li>
						<li>
							The risk value of each road can be converted into a numerical value, to use as a multiplier in the graph. The weight of each edge (road) on the graph is multiplied by the risk of the road, to give a new weight that takes into account both distance and risk. This new weight is then used by the A* algorithm to calculate the route.
						</li>
						<li>
							The multipliers can be adjusted to prioritise risk over distance, or vice versa. For example, an emergency service vehicle would prioritise speed over safety, and therefore the risk multipliers would be lowered to prioritise distance. Other vehicles, such as a lorry carrying hazardous materials, or a coach full of passengers, would prioritise safety over speed, and therefore the risk multipliers would be increased to prioritise risk.
						</li>
					</ol>
				</section>

				<section class="step">
					<h2>The Optimal Route, Town 1</h2>

					<figure class="image split">
						<img src="img/Town1AStarRisk1,2,4.png">

						<figcaption>
							<p>
								With a method of distilling distance and risk into one value, this can use this to calculate the optimal route, using the same A* algorithm as previous.
							</p>
							<p>
								Since blue is described as twice as busy (and therefore twice as risky) as gree, and red twice as busy as blue, the multipliers of 1, 2, and 4 were used.
								This means that if a road borders a blue area, its weight is doubled, and if it borders a red area, its weight is quadrupled. As can be seen above, the path taken by the algorithm completely avoids the red area, and only enters a blue area momentarily.
							</p>
						</figcaption>
					</figure>


				</section>
			</section>


			<section class="col">
				<section class="step">
					<h2>Testing on Town 2</h2>
					<!-- 
						We need to test our algorithm on a new town
					-->

					<figure class="image split">
						<img src="img/Town2AStarRisk1,2,4.png">

						<figcaption>
							<p>
								Now that the algorithm has been tested on the initial town, we can ensure its generalisability by testing it on a new town.
							</p>

							<p>
								The steps of creating the graph, calculating the fastest route, and calculating the optimal route are repeated for Town 2.
							</p>

							<p>
								As previously, the route calculated takes into account the distance and risk of each road, and the risk multipliers can be adjusted to prioritise speed or safety.
							</p>
						</figcaption>
					</figure>
				</section>

				<section class="step">
					<h2>A Third Town</h2>
					<figure class="image split">
						<img src="img/BournvilleRisk1,2,4.png">

						<figcaption>
							<p>This third town is based on the real suburb of Bournville, Birmingham. The risks for each area are based on the amenities within each area, to reflect a more realistic concentration of 'business.' Unlike the towns provided, this town has a more complex layout, and the areas of risk do not follow a simple pattern with red in the centre, blue in the middle, and green on the outskirts.</p>
						</figcaption>
					</figure>
				</section>

				<section class="step">
					<h2>Conclusions &amp; Possible Improvements</h2>
					<ol>
						<li>The algorithm, in avoiding busy areas, often spends significant time going further away from the end goal. A stronger heuristic would make it more likely to head more directly to the destination.</li>
						<li></li>
					</ol>
				</section>
			</section>
		</article>
	</main>

	
<script>
	document.querySelectorAll("li.frame").forEach(frame => {
		frame.style.display = "none";
	});

	let currentFrame = 0;
	let frames = document.querySelectorAll("li.frame");

	function nextFrame() {
		try {
			frames[currentFrame].style.display = "none";
		} catch (e) {}
		currentFrame = (currentFrame + 1) % frames.length;
		frames[currentFrame].style.display = "flex";
	}

	nextFrame();

	window.setInterval(nextFrame, 3000);
</script>
</body>
</html>